from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, List
import json
import logging
from datetime import datetime

from .agents.questionarie_rh import QuestionarieRHAgent
from auth.db.sqlite_db import get_session_db, update_session_db, save_conversation_response
from .models.schemas import WebSocketMessage

logger = logging.getLogger(__name__)

class WebSocketManager:
    """
    Maneja las conexiones WebSocket y la comunicaci√≥n con los agentes conversacionales
    """
    
    def __init__(self):
        # Diccionario para almacenar conexiones activas: {session_id: websocket}
        self.active_connections: Dict[str, WebSocket] = {}
        # Diccionario para almacenar agentes activos: {session_id: agent}
        self.active_agents: Dict[str, QuestionarieRHAgent] = {}
    
    async def connect(self, websocket: WebSocket, session_id: str):
        """
        Acepta una nueva conexi√≥n WebSocket para una sesi√≥n espec√≠fica
        """
        try:
            await websocket.accept()
            self.active_connections[session_id] = websocket
            logger.info(f"‚úÖ WebSocket conectado para sesi√≥n: {session_id}")
            
            # Inicializar agente si no existe
            agent_already_existed = session_id in self.active_agents
            if not agent_already_existed:
                await self._initialize_agent(session_id)
            
            # Enviar mensaje de bienvenida solo si el agente no exist√≠a previamente
            # (Si ya exist√≠a, significa que se inici√≥ desde start_questionnarie)
            if session_id in self.active_agents and not agent_already_existed:
                welcome_message = self.active_agents[session_id].start_conversation()
                await self.send_message(session_id, "agent_response", welcome_message)
            
        except Exception as e:
            logger.error(f"‚ùå Error al conectar WebSocket para sesi√≥n {session_id}: {str(e)}")
            raise
    
    def disconnect(self, session_id: str):
        """
        Desconecta una sesi√≥n espec√≠fica
        """
        if session_id in self.active_connections:
            del self.active_connections[session_id]
            logger.info(f"üîå WebSocket desconectado para sesi√≥n: {session_id}")
        
        # Mantener el agente por si se reconecta
        # if session_id in self.active_agents:
        #     del self.active_agents[session_id]
    
    async def send_message(self, session_id: str, message_type: str, content: str, data: Dict = None):
        """
        Env√≠a un mensaje a una sesi√≥n espec√≠fica
        """
        if session_id in self.active_connections:
            websocket = self.active_connections[session_id]
            
            message = WebSocketMessage(
                type=message_type,
                content=content,
                session_id=session_id,
                data=data or {}
            )
            
            try:
                await websocket.send_text(message.model_dump_json())
                logger.debug(f"üì§ Mensaje enviado a {session_id}: {message_type}")
            except Exception as e:
                logger.error(f"‚ùå Error enviando mensaje a {session_id}: {str(e)}")
                # Limpiar conexi√≥n inv√°lida
                self.disconnect(session_id)
    
    async def handle_user_message(self, session_id: str, message: str):
        """
        Procesa un mensaje del usuario y genera la respuesta del agente
        """
        try:
            logger.info(f"üí¨ Procesando mensaje de usuario en sesi√≥n {session_id}: {message[:50]}...")
            
            if session_id not in self.active_agents:
                await self._initialize_agent(session_id)
            
            if session_id not in self.active_agents:
                await self.send_message(session_id, "error", "No se pudo inicializar el agente conversacional")
                return
            
            # Guardar informaci√≥n antes de procesar (para capturar pregunta actual)
            agent = self.active_agents[session_id]
            current_question = agent.state.current_question
            current_question_index = agent.state.current_question_index
            
            # Procesar mensaje con el agente
            agent_response = agent.process_user_input(message)
            
            # Solo guardar si hab√≠a una pregunta activa y la respuesta fue aceptada
            # (es decir, si no necesita clarificaci√≥n)
            if current_question and not agent.state.needs_clarification:
                # Guardar la respuesta en la base de datos
                try:
                    success = save_conversation_response(
                        session_id=session_id,
                        id_question=current_question_index,
                        question=current_question,
                        response=message
                    )
                    if success:
                        logger.info(f"üíæ Respuesta guardada en BD para sesi√≥n {session_id}, pregunta {current_question_index}")
                    else:
                        logger.warning(f"‚ö†Ô∏è No se pudo guardar respuesta en BD para sesi√≥n {session_id}")
                except Exception as e:
                    logger.error(f"‚ùå Error guardando respuesta en BD: {str(e)}")
            
            # Verificar si la conversaci√≥n se complet√≥
            is_complete = agent.is_conversation_complete()
            
            # Si la conversaci√≥n est√° completa, actualizar estado en la base de datos
            if is_complete:
                await self._update_session_to_complete(session_id, agent)
            
            # Enviar respuesta del agente
            await self.send_message(
                session_id, 
                "agent_response", 
                agent_response,
                {
                    "is_complete": is_complete,
                    "summary": agent.get_conversation_summary() if is_complete else None
                }
            )
            
            logger.info(f"‚úÖ Respuesta del agente enviada para sesi√≥n {session_id}")
            
        except Exception as e:
            logger.error(f"‚ùå Error procesando mensaje de usuario en sesi√≥n {session_id}: {str(e)}")
            await self.send_message(session_id, "error", f"Error interno: {str(e)}")
    
    async def initialize_agent(self, session_id: str, session_data: Dict = None):
        """
        Inicializa un agente conversacional para la sesi√≥n (m√©todo p√∫blico)
        
        Args:
            session_id: ID de la sesi√≥n
            session_data: Datos de la sesi√≥n (opcional, si no se provee se obtiene de BD)
        """
        try:
            # Usar datos proporcionados o obtener de BD
            if not session_data:
                session_data = get_session_db(session_id)
                
            if not session_data:
                logger.error(f"‚ùå No se encontr√≥ sesi√≥n en BD: {session_id}")
                return False
            
            # Extraer preguntas del content
            content = session_data.get('content', {})
            questions = content.get('questions', [])
            
            if not questions:
                logger.warning(f"‚ö†Ô∏è No hay preguntas configuradas para sesi√≥n: {session_id}")
                return False
            
            # Crear agente con las preguntas espec√≠ficas
            agent = QuestionarieRHAgent(questions=questions)
            self.active_agents[session_id] = agent
            
            logger.info(f"ü§ñ Agente inicializado para sesi√≥n {session_id} con {len(questions)} preguntas")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando agente para sesi√≥n {session_id}: {str(e)}")
            return False

    async def _initialize_agent(self, session_id: str):
        """
        Inicializa un agente conversacional para la sesi√≥n (m√©todo privado - wrapper del p√∫blico)
        """
        await self.initialize_agent(session_id)

    def get_welcome_message(self, session_id: str) -> str:
        """
        Obtiene el mensaje de bienvenida del agente sin necesidad de WebSocket
        
        Args:
            session_id: ID de la sesi√≥n
            
        Returns:
            str: Mensaje de bienvenida del agente o None si no hay agente
        """
        if session_id in self.active_agents:
            try:
                # Usar directamente start_conversation() del agente
                welcome_message = self.active_agents[session_id].start_conversation()
                logger.info(f"ü§ñ Mensaje de bienvenida obtenido para sesi√≥n: {session_id}")
                return welcome_message
            except Exception as e:
                logger.error(f"‚ùå Error obteniendo mensaje de bienvenida para sesi√≥n {session_id}: {str(e)}")
                return None
        else:
            logger.warning(f"‚ö†Ô∏è No hay agente inicializado para sesi√≥n: {session_id}")
            return None
    
    async def _update_session_to_complete(self, session_id: str, agent: QuestionarieRHAgent):
        """
        Actualiza el estado de la sesi√≥n a 'complete' en la base de datos.
        
        Args:
            session_id: ID de la sesi√≥n
            agent: Instancia del agente con los datos de la conversaci√≥n
        """
        try:
            logger.info(f"üìù Actualizando estado de la sesi√≥n {session_id} a 'complete'...")
            
            # Obtener resumen de la conversaci√≥n del agente
            conversation_summary = agent.get_conversation_summary()
            
            # Crear content actualizado con el resumen
            final_content = {
                "questions": agent.questions,
                "responses": conversation_summary.get("responses", {}),
                "completed_at": datetime.utcnow().isoformat(),
                "total_questions": conversation_summary.get("total_questions", 0),
                "total_responses": conversation_summary.get("questions_asked", 0),
                "messages_count": conversation_summary.get("messages_count", 0)
            }
            
            # Actualizar el estado en la base de datos
            updated_session = update_session_db(
                session_id=session_id,
                type_value="questionnarie",  # Mantener el tipo original
                status="complete",  # Cambiar estado a complete
                content=final_content,
                configs={}  # Configs vac√≠o por ahora
            )
            
            if updated_session:
                logger.info(f"‚úÖ Estado de sesi√≥n actualizado a 'complete': {session_id}")
            else:
                logger.warning(f"‚ö†Ô∏è No se pudo actualizar el estado de la sesi√≥n: {session_id}")
                
        except Exception as e:
            logger.error(f"‚ùå Error al actualizar estado de sesi√≥n {session_id}: {str(e)}")

# Instancia global del manager
websocket_manager = WebSocketManager() 